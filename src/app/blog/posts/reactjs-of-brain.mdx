---
title: 'Реакт головного мозга'
publishedAt: '2024-02-21'
description: 'Всегда слышал выражение «Java-головного мозга». Так называли
            программистов, которые из-за длительного использования одного языка
            или фреймворка (структуры) или библиотеки начинают решать простые
            задачи сложно и запутанно, потому что они привыкли к определенной
            плоскости решения проблем, которую диктует этот язык или
            общепринятые практики на нем.'
tags: "React"
---

Всегда слышал выражение «Java-головного мозга». Так называли программистов, которые из-за длительного использования одного языка или фреймворка (структуры) или библиотеки начинают решать простые задачи сложно и запутанно, потому что они привыкли к определенной плоскости решения проблем, которую диктует этот язык или общепринятые практики на нем.

Я всегда думал, что меня это не коснется, но, как оказалось, даже не заметил, как это произошло. Я уже долгое время работаю со стеком React и настолько привык к его поведению, что стал рассматривать проблемы только в рамках того, что предоставляет React, его инструментарий. Просто перестал задумываться о том, что некоторые задачи можно решить более простым способом.

Ндеавно мне прислали баг, что пользователи не могут что-то сделать, у них не открывается модальное окно. Хотя код не менялся уже долгое время. Давайте покажу код и ui, чтобы проиллюстрировать проблему. На самом деле, нам не важно, как выглядит само модальное окно, оно может быть любым и содержать что угодно. Важно то, что оно должно открываться и закрываться при нажатии на кнопку и на клик по контейнеру.

> Интересно, что пользователи даже не пытались нажать на контейнер. Давайте не будем вдаваться в подробности, почему это так произошло с точки зрения реализации UX. Что это плохая практика вешать один онклик на контейнер и на дочерние элементы. Что если уж онклик и весит зачем-то на диве, то хотя бы роль повесить баттон, иначе сабмитить будет все, что плохо лежит, и т.д., давайте это все опустим.

При клике на контейнер все работает, модальное окно открывается и закрывается, но при клике на кнопку ничего не происходит.

```ts
import { useState, useCallback } from "react";

import "./styles.css";

type UseToogle = () => [boolean, () => void];

const useToogle: UseToogle = () => {
  const [isOn, toogleRaw] = useState(false);

  const toogle = useCallback(() => {
    toogleRaw(!isOn);
  }, []);

  return [isOn, toogle];
};

export default function App() {
  const [isOn, toogle] = useToogle();

  return (
    <>
      <dialog open={isOn} className="Modal">
        Модальное окно
      </dialog>
      <div className="app" onClick={toogle}>
        <button onClick={toogle} className="PopupButton">
          Открыть модальное окно
        </button>
      </div>
    </>
  );
}
```

Важной особенностью является то, что в примере я показываю реализацию хука useToggle, однако на самом деле он просто был импортирован из внешней библиотеки. Версию давно не обновляли. И проблема воспроизводилась только на сервере разработки, где, как выяснилось позже, при сборке проекта пакет обновлялся. 

Первое, что я подумал - возможно, проблема в том, как реализована useToggle, и это вызывает лишние перерисовки, что приводит к сбросу состояния. Или, наоборот, убирает перерисовки из-за того, что состояние просто не меняется. 

> Забавно, что меня не смутило то, что при клике на контейнер все работает.

Я начал дебажить состояние и смотреть, что вызывает перерисовки. Выдвигать теории, почему это перестало вдруг работать, хотя основной код приложения не менялся. После того, как посмотрел, что состояние на кнопку не меняется, я полез смотреть реализацию useToggle и обнаружил, что ребята решили оптимизировать useToggle и изменили его немного, чтобы не вызывать лишние перерисовки. И тут я понял, что это и было ошибкой. Раньше компонент перерисовывался на смену состояния, и модальное окно отображалось. Но теперь, после оптимизации, компонент не перерисовывается, и не меняет состояние.

```ts
const useToogle: UseToogle = () => {
  const [isOn, toogleRaw] = useState(false);

  const toogle = useCallback(() => {
    toogleRaw(!isOn);
  }, []);

  return [isOn, toogle];
};

```

```ts
const useToogle: UseToogle = () => {
  const [isOn, toogleRaw] = useState(false);

  const toogle = useCallback(() => {
    toogleRaw(!isOn);
  }, []);

  return [isOn, toogle];
};

```

Как забавно происходит, когда долго работаешь с одной технологией и начинаешь мыслить только в ее рамках. Просто пытаешься решить проблему в рамках этой технологии, не подумав никак иначе.

Давайте я вам намекну, и вы сразу все поймете. 

```ts
const useToogle: UseToogle = () => {
  const [isOn, toogleRaw] = useState(false);

  const toogle = useCallback(() => {
    toogleRaw(!isOn);
  }, []);

  return [isOn, toogle];
};

```

Понимаете, к чему я веду? Простое всплытие событий! Когда событие всплывает из самого глубокого элемента вверх. Самым глубоким элементом в нашем случае является кнопка. Обработчик события сначала срабатывает на кнопке. Потом идет вверх, доходит до контейнера и срабатывает на нем. И мы получаем при клике на кнопку смену состояния на true, при срабатывании на контейнер - false. 

> Забавно, что при дебаге, если посмотреть состояние, в 18-й версии React есть автоматический батчинг состояний, это когда он собирает несколько одинаковых состояний за одну перерисовку. В результате мы увидим последнее измененное состояние, и это будет false, если у вас версия React ниже 18-й, вы увидите сначала смену состояния в true, а потом в false. 

Вот такая вот получилась история моего React-головного мозга. 

Спасибо, что дочитали до конца. Возможно, вы подумаете, что все это было очевидно с самого начала. Я вам скажу - ничего подобного! Я пробовал давать это задание коллегам и друзьям, и все, кто как ни пытался, чтобы починить компонент, навешивали рефы, отслеживали и группировали события и т.д., смотрели перерисовки. И когда они понимали, что проблема во всплытии событий, все улыбались, потому что иногда забываешь очевидные вещи.

Бонусом хочу сказать, что из этой истории вылилось небольшое забавное задание. Попросите кого-то из коллег или друзей починить компонент и понаблюдайте, как они это будут делать. [Вот ссылка на компонент](https://codesandbox.io/p/sandbox/practical-mayer-n98l5m). Там две ошибки, одна связана с мемоизацией состояния, другая - со всплытием.